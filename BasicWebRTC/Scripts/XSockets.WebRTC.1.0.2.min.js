XSockets.WebRTC = function (g, d) { var h = this; var f; this.PeerConnections = {}; this.DataChannels = {}; var e = { iceServers: { iceServers: [{ url: "stun:stun.l.google.com:19302" }] } }; var i = XSockets.Utils.extend(e, d); var b = (function () { var l = []; this.add = function (n, q, o) { n = n.toLowerCase(); var m = this.get(n); if (m === null) { var p = new j(n); p.addCallback(q, o); l.push(p); return 1 } m.addCallback(q, o); return m.Callbacks.length }; this.get = function (m) { m = m.toLowerCase(); for (var n = 0; n < l.length; n++) { if (l[n].Name === m) { return l[n] } } return null }; this.getAll = function () { return l }; this.remove = function (n, m) { n = n.toLowerCase(); for (var o = 0; o < l.length; o++) { if (l[o].Name === n) { if (m === undefined) { l.splice(o, 1) } else { l[o].Callbacks.splice(m - 1, 1); if (l[o].Callbacks.length === 0) { l.splice(o, 1) } } return true } } return false }; this.fire = function (o, q, m, n) { o = o.toLowerCase(); for (var p = 0; p < l.length; p++) { if (l[p].Name === o) { if (n === undefined) { l[p].fireCallbacks(q, m) } else { l[p].fireCallback(q, m, n) } } } }; var j = function (m) { this.Name = m; this.Callbacks = []; this.addCallback = function (o, n) { this.Callbacks.push(new k(o, n)) }; this.fireCallback = function (p, n, o) { this.Callbacks[o - 1].fn(p); if (typeof (this.Callbacks[o - 1].state) === "object") { if (typeof (this.Callbacks[o - 1].state.options) !== "undefined" && typeof (this.Callbacks[o - 1].state.options.counter) !== "undefined") { this.Callbacks[o - 1].state.options.counter.messages--; if (this.Callbacks[o - 1].state.options.counter.messages === 0) { if (typeof (this.Callbacks[o - 1].state.options.counter.completed) === "function") { this.Callbacks[o - 1].state.options.counter.completed() } } } } if (n && typeof (n) === "function") { n() } }; this.fireCallbacks = function (o, n) { for (var p = 0; p < this.Callbacks.length; p++) { this.fireCallback(o, n, p + 1) } } }; var k = function (n, m) { this.fn = n; this.state = m }; return this }); this.bind = function (l, j, k, m) { a.add(l, j); if (m && typeof (m) === "function") { m() } }; this.unbind = function (j, k) { a.remove(j); if (k && typeof (k) === "function") { k() } }; this.dispatch = function (j, k, l) { if (a.get(j) === null) { console.log("this", j, a.getAll()); return } if (typeof k === "string") { k = JSON.parse(k) } a.fire(j, k, function () { }) }; var a = new b(); this.channelPublish = function (m, j) { for (var n in h.DataChannels) { var l = h.DataChannels[n]; if (l.readyState === "open") { var k = new XSockets.Message(m, j); l.send(JSON.stringify(k)) } } }; this.closeChannel = function (j) { h.DataChannels[j].close() }; this.channelSubscribe = function (j, k, l) { h.bind(k + j, l) }; this.channelUnsubscribe = function (j, k, l) { h.unbind(k + j, l) }; var c = function (m, k) { var l = this; this.StorageGuid = k; this.RTCPeerConnection = new RTCPeerConnection(m.iceServers, { optional: [{ RtpDataChannels: true }] }); this.RTCPeerConnection.onconnection = function () { }; try { h.DataChannels[k] = this.RTCPeerConnection.createDataChannel("RTCDataChannel", { reliable: false }); h.DataChannels[k].onmessage = function (o) { var n = JSON.parse(o.data).JSON; h.dispatch(l.StorageGuid + n.event, n.data, l.StorageGuid) }; h.DataChannels[k].onopen = function () { h.dispatch(XSockets.WebRTC.Events.onDataChannelOpen, { StorageGuid: h.DataChannels[k] }) }; h.DataChannels[k].onclose = function () { h.dispatch(XSockets.WebRTC.Events.onDataChannelClose, { StorageGuid: h.DataChannels[k] }) } } catch (j) { console.log("'Create Data channel failed with exception:", j.message) } this.RTCPeerConnection.onstatechange = function (n) { }; this.RTCPeerConnection.onaddstream = function (n) { h.dispatch(XSockets.WebRTC.Events.onRemoteStream, { StorageGuid: l.StorageGuid, MediaStreamEvent: n }) }; this.RTCPeerConnection.onicecandidate = function (o) { if (o.candidate) { var n = { type: "candidate", label: o.candidate.sdpMLineIndex, id: o.candidate.sdpMid, candidate: o.candidate.candidate }; g.publish("contextsignal", { sender: h.CurrentContext.StorageGuid, recipient: k, message: JSON.stringify(n) }) } }; h.dispatch(XSockets.WebRTC.Events.onPeerConnectionCreated, { StorageGuid: l.StorageGuid }) }; h.bind("connect", function (j) { h.PeerConnections[j.StorageGuid] = new c(i, j.StorageGuid); if (f) { h.PeerConnections[j.StorageGuid].RTCPeerConnection.addStream(f) } h.PeerConnections[j.StorageGuid].RTCPeerConnection.createOffer(function (k) { h.PeerConnections[j.StorageGuid].RTCPeerConnection.setLocalDescription(k); g.publish("contextsignal", { sender: h.CurrentContext.StorageGuid, recipient: j.StorageGuid, message: JSON.stringify(k) }) }, null, { mandatory: { OfferToReceiveAudio: true, OfferToReceiveVideo: true } }) }); h.bind("candidate", function (k) { var j = JSON.parse(k.Message); h.PeerConnections[k.Sender].RTCPeerConnection.addIceCandidate(new RTCIceCandidate({ sdpMLineIndex: j.label, candidate: j.candidate })) }); h.bind("answer", function (j) { h.PeerConnections[j.Sender].RTCPeerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(j.Message))) }); h.bind("offer", function (j) { h.PeerConnections[j.Sender] = new c(i, j.Sender); h.PeerConnections[j.Sender].RTCPeerConnection.setRemoteDescription(new RTCSessionDescription(JSON.parse(j.Message))); if (f) { h.PeerConnections[j.Sender].RTCPeerConnection.addStream(f) } h.PeerConnections[j.Sender].RTCPeerConnection.createAnswer(function (k) { h.PeerConnections[j.Sender].RTCPeerConnection.setLocalDescription(k); g.publish("contextsignal", { sender: h.CurrentContext.StorageGuid, recipient: j.Sender, message: JSON.stringify(k) }) }, null, { mandatory: { OfferToReceiveAudio: true, OfferToReceiveVideo: true } }) }); g.subscribe("contextcreated", function (j) { h.CurrentContext = new XSockets.PeerContext(j.StorageGuid, j.Context); h.dispatch(XSockets.WebRTC.Events.onContextCreated, j) }); g.subscribe("contextsignal", function (j) { var k = JSON.parse(j.Message); h.dispatch(k.type, j) }); g.subscribe("contextchange", function (j) { h.dispatch(XSockets.WebRTC.Events.onContextChange, j) }); g.subscribe("connectto", function (j) { j.forEach(function (k) { h.dispatch("connect", k) }) }); g.subscribe("peerlost", function (j) { if (h.PeerConnections[j.StorageGuid] !== undefined) { h.PeerConnections[j.StorageGuid].RTCPeerConnection.close(); h.dispatch(XSockets.WebRTC.Events.onPeerConnectionLost, { StorageGuid: j.StorageGuid }) } }); this.ready = function (j) { g.publish("initializecontext", { screenName: j }) }; this.changeContext = function (j) { g.publish("changecontext", { guid: j }) }; this.getUserMedia = function (j, k) { window.getUserMedia(j, function (l) { f = l; h.dispatch(XSockets.WebRTC.Events.onlocalStream, l); if (k && typeof (k) === "function") { k(h.CurrentContext) } }) } }; XSockets.PeerContext = function (a, b) { this.StorageGuid = a; this.Context = b }; XSockets.WebRTC.CallManager = function (a, c) { var b = c.events; this.call = function (d) { a.trigger("OfferContext", { storageGuid: d.StorageGuid }) }; this.setScreenName = function (d) { a.trigger("PeerScreenName", { screenName: d }) }; this.acceptCall = function (d) { b.onAcceptCall(d) }; this.denyCall = function (d) { a.trigger("DenyContext", { storageGuid: d.StorageGuid }) }; this.endCall = function () { a.trigger("LeaveContext", {}) }; a.subscribe("ContextOffer", b.onCall); a.subscribe("ContextDeny", b.onDenyCall) }; Array.prototype.indexOfObject = function (b) { for (var a = 0; a <= this.length; a++) { if (typeof (this[a]) === "object" && JSON.stringify(this[a]) === JSON.stringify(b)) { return a } } if (a > this.length) { return -1 } else { return a } }; XSockets.WebRTC.Events = { onlocalStream: "onLocalStream", onRemoteStream: "onRemoteStream", onContextChange: "onContextChange", onContextCreated: "onContextCreated", onPeerConnectionCreated: "onPeerConnectionCreated", onPeerConnectionLost: "onPeerConnectionLost", onDataChannelOpen: "onDataChannelOpen", onDataChannelClose: "onDataChannelClose" };